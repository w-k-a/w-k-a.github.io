{"meta":{"title":"Fuqiong博客","subtitle":"保存好您做过的所有源文件","description":"请勿把工作与兴趣混合","author":"FuqiongWang","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"面试前端相关题目","slug":"面试前端相关题目","date":"2020-12-09T09:27:08.000Z","updated":"2020-12-16T07:50:58.287Z","comments":true,"path":"2020/12/09/面试前端相关题目/","link":"","permalink":"http://example.com/2020/12/09/%E9%9D%A2%E8%AF%95%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/","excerpt":"","text":"ajax是什么？如何创建一个ajax?Aiax并不是一种新的技术，全称是asyncronous javascript and xml,可以说是已有技术的组合，主要用来实现客服端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax,可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持使用使用ajax原生方式发送请求主要通过XMLHttprequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果。 Ajax优缺点： 1.优点 页面局部刷新，用户体验好。 异步通信，更加快响应能力。 减少冗余请求，减轻了服务器负担；按需要获取数据，节约宽带资源。 基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 2.缺点 ajax干掉了back按钮和加入收藏书签功能，即对浏览器后退机制的破环。 存在一定的安全问题，Ajax暴露了与服务器交互的细节。 对搜索引擎的支持特别弱。 破环了程序的异常机制。 无法用URL直接访问。 创建ajax的步骤 Ajax的原理简单来说通过XMLHttprequest对象来向服务器发送请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。其中就关键的一步就是从服务器获得请求数据。 Ajax过程： 创建XMLHttprequest对象，也就是创建一个异步调用对象 XMLHttprequest是ajax的基础。XMLHttprequest用于在后台与服务器交换数据。这就意味着可以不用重新加载整个网页的情况下，对网页的某部分进行更新。所有现代浏览器均支持xmlhttpRequest对象（ie5和ie6使用activeXObiect）。 123456789var xhr;if (window.XMLHttpRequest)&#123; &#x2F;&#x2F; IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xhr &#x3D; new XMLHttpRequest();&#125; else &#123; &#x2F;&#x2F; IE6, IE5 浏览器执行代码 xhr &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125; ​ 创建一个新的HTTP请求，并指定该HTTP请求的方法、url及验证信息 如需将请求发送到服务器，我们使用XMLhttpRequest对象的open()和send()方法。 方法 描述 open（method，url,async） 规定请求的类型、url以及是否异步处理请求。1、method:请求的类型；get或者post.2、url:文件在服务器上的位置。3、async:true(异步)或false(同步) send(string) 将请求发送到服务器。1、string:仅用于post请求 1234567&#x2F;&#x2F; 一个简单的get请求xhr.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);xhr.send(); &#x2F;&#x2F; 一个简单的post请求xhr.open(&quot;POST&quot;,&quot;&#x2F;try&#x2F;ajax&#x2F;demo_post.php&quot;,true);xhr.send() ​ 设置相应HTTP请求状态变化的函数 当请求被发送到服务器时，我们需要执行一些基于响应的任务，每当readystate改变时，就会触发onreadystatechange事件。readystate属性存有XMLHttpRequest的状态信息。 方法 描述 onreadystatechange 存储函数（或函数名），每当readyState属性改变时，就会调用该函数 readyState 存有XMLHttpResquest的状态。从0到4发生变化。0代表请求未初始化，1代表服务器连接已经建立，2代表请求已经接收，3代表请求处理中。4代表请求已完成，且响应已就绪 status 200：”ok”,400:未找到页面 12345xhr.onreadystatechange &#x3D; function()&#123; if(xhr.readyState &#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D; 200)&#123; console.log(xhr.responseText); &#x2F;&#x2F; responseText获取字符串形式的响应数据 responseXML获取XML形式的响应数据 &#125; &#125; ​ 发送http请求 获取异步调用的返回的数据 使用JavaScript和DOM实现局部刷新 ​ 原生ajax实例1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;head&gt; &lt;body&gt; &lt;div id&#x3D;&quot;myDiv&quot;&gt; &lt;h2&gt;使用 AJAX 修改该文本内容&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; &lt;button type&#x3D;&quot;button&quot; onclick&#x3D;&quot;loadXMLDoc()&quot;&gt;修改内容&lt;&#x2F;button&gt; &lt;script&gt; function loadXMLDoc() &#123; var xhr; if (window.XMLHttpRequest) &#123; &#x2F;&#x2F; IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xhr &#x3D; new XMLHttpRequest(); &#125; else &#123; &#x2F;&#x2F; IE6, IE5 浏览器执行代码 xhr &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; xhr.onreadystatechange &#x3D; function () &#123; if (xhr.readyState &#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D; 200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML &#x3D; xhr.responseText; &#125; &#125; xhr.open(&quot;GET&quot;, &quot;&#x2F;try&#x2F;ajax&#x2F;ajax_info.txt&quot;, true); xhr.send(); &#125; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 使用jquery封装ajax请求方法 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.10.2&#x2F;jquery.min.js&quot;&gt; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt; &lt;body&gt; &lt;div id&#x3D;&quot;myDiv&quot;&gt; &lt;h2&gt;使用 jQuery AJAX 修改文本内容&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; &lt;button&gt;修改内容&lt;&#x2F;button&gt; &lt;script&gt; $(document).ready(function () &#123; $(&quot;button&quot;).click(function () &#123; htmlobj &#x3D; $.ajax(&#123; type: &quot;GET&quot;, url: &quot;&#x2F;jquery&#x2F;test1.txt&quot;, data: &#123;&#125;, dataType: &quot;json&quot;, async: false, success: function (data) &#123; $(&quot;#myDiv&quot;).html(data); &#125; &#125;); &#125;); &#125;); &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; ​ 什么是json,优缺点RESTful是什么class的使用简述箭头函数需要注意什么JavaScript如何检测一个变量是一个string类型请用js去除字符串的空格==和===的区别如何达到浮点数的精度forEach、map、filter的区别你如何获取浏览器中URL中查询字符串中的参数正则表达式，验证手机号码，验证规则：11位数字，以1开头已知有字符串foo=’get-element-by-id’,写一个function将其转化为驼峰法如：getElementByid伪类和伪元素的区别伪类：用于已有元素处于某种状态时为其添加的对应的样式，这个状态是根据用户行为的变化行为而改变的。如用户悬停在指定元素时，可以通过:hover来描述这个元素的状态。虽然他和一般css相似，可以为已有元素添加元素样式，但是他只有处于DOM树无法描述的状态下才能为元素添加样式，所以称为伪类。 伪元素：用于创建一些不在DOM元素中的元素，并为其添加样式。例如，我们可以通过:berfor 来在一个元素之前添加一些文本，并为这些文本添加样式，虽然用户可以看的见这些文本，但是它实际上并不存在DOM文档中。","categories":[],"tags":[{"name":"前端笔试","slug":"前端笔试","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95/"}]},{"title":"vue常见面试题","slug":"vue常见面试题","date":"2020-11-24T09:20:30.000Z","updated":"2020-11-25T09:22:27.046Z","comments":true,"path":"2020/11/24/vue常见面试题/","link":"","permalink":"http://example.com/2020/11/24/vue%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"v-if和v-show是做什么的，两者的区别？v-if是“真正的”条件渲染，因为他会确保在切换过程中条件块内的事件监听器和子组件适当的销毁和重建。 v-if有惰性，如果初始条件为假，则什么都不会坐一直到条件为真，才会开始渲染条件块 相比之下，v-show就简单的多，不管初始条件是什么，元素总会被渲染，并且只是简单地基于css进行切换。 一般来说，v-if有更高的切换开销，而v-show有更高的初始化渲染开销。因此如果需要非常频繁的切换，使用v-show比较好，如果运行时条件不怎么变化，则使用v-if比较好。 如何让css只在当前组件中起作用在style里面加入scoped 扩展：但是如果里面还引用了在sass 或者 stylus，修改其他插件组件的时候样式没有效果，这时候需要使用穿透符/deep/ 或者&gt;&gt;&gt;,使用方法是父元素/deep/子元素、父元素&gt;&gt;&gt;子元素。 v-model使用可以实现双向绑定。在input或者select或者文本域配合value使用 vue-loader是什么？使用它的用途有哪些？解析.vue文件的一个加载器，能把template/js/style转化为js模块。 用途：js可以写成es6、style样式可以是scss或是less、template可以加jade等 NextTick是做什么的nextTick是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用 nextTick,则可以在回调中获取更新后的DOM. 场景：需要在视图更新之后，基于新的视图进行操作。","categories":[],"tags":[]},{"title":"如何提高编写性能的JavaScript","slug":"如何提高编写性能的JavaScript","date":"2020-11-19T08:51:42.000Z","updated":"2020-11-20T07:42:48.384Z","comments":true,"path":"2020/11/19/如何提高编写性能的JavaScript/","link":"","permalink":"http://example.com/2020/11/19/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%BC%96%E5%86%99%E6%80%A7%E8%83%BD%E7%9A%84JavaScript/","excerpt":"","text":"如何编写高性能的JavaScript 遵循严格模式：“use strict”； 将js脚本放在页面底部，加快渲染页面； 将Js脚本成组打包，减少请求； 尽量使用局部变量来保存全局变量； 尽量减少使用闭包； 使用window对象属性方法时，省略window； 尽量减少对象的成员嵌套； 缓存DOM节点的访问； 通过避免使用eval（）和Function（）构造器； 给setTimeout()和setInterval()传递函数而不是字符串作为参数； 尽量使用直接量创建对象和数组； 最小化重绘（repaint）和回流（reflow） cookies,sessionStorage和localStorage的区别相同点：都存储在客户端 不同点 存储大小：cookie数据大小不能超过4k。seeeionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或者更大。 有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失，除非主动删除数据；sessionStorage数据在浏览器关闭窗口之后就会自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或者浏览器关闭。 数据于服务器之间的交互方式：cookie的数据会自动传递到服务器，服务器端也可以写cookie到客服端；localStorage和sessionStorage不会自动把数据发给服务器，仅在本地保存。 作用域：localStorage的作用域限制在文档源，localStorage同源的文档之间可以相互访问和修改相同名称的数据；localStorage受到浏览器厂商的限制，chrome下存储的数据，360浏览器下不可访问；会得到‘Invalid Date’。sessionStorage在localStorage的同源策略基础之上，还有更严格的限制；他还被限制在窗口中，意思是同一个窗口或者标签页的不同页面之间可以共享seessionStorage;但是不同的窗口或者标签页之间不能共享sessionStorage，即便他们是在同一个地址；这里的窗口时顶级窗口，如果里面有多个iframe,他们之间共享sessionStorage。 请指出document load 和 document ready 的区别？相同点：两种事件都代表的是页面文档加载时触发。 不同点： ready:文档结构已经加载完成，不含图片等非文字媒体资源。 onload:表示包含图片等文件在内的所有元素及资源都加载完成。 事件的三个阶段捕获、木标、冒泡 捕获阶段：当我们在DOM树的某个节点发生了一些操作（如单机、鼠标移动），就会有一个事件发射过去。这个事件从window发出，不断经过下级节点直到触发到目标节点。在到达目标节点之前的过程，就是捕获阶段。事件由页面元素接收，逐及向下，到具体的元素。 目标阶段 ：当事件不断传递直到目标节点的时候，最终在目标节点上触发这个事件，就是目标阶段。具体元素身。 冒泡阶段：事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点。跟捕获相反，具体元素本身，逐级向上，到页面元素。 事件执行模式： 事件捕获时，父元素先触发，子元素后触发 事件冒泡时，子元素先触发，父元素后触发。W3C标准默认是事件冒泡。 标准浏览器通过addEventListener(“click”, function, true)方法实现事件捕获模式，IE不支持事件捕获，用ele.attachEvent(“onclick”, doSomething)。 阻止事件传播： 在W3C中，使用e.stopPropagation()方法。 在IE下使用cancelBubble=true方法。 阻止默认事件： 在W3C中，使用preventDefault()方法。 在IE下return false.","categories":[],"tags":[]},{"title":"react学习笔记","slug":"react学习笔记","date":"2020-11-13T02:52:30.000Z","updated":"2020-11-14T04:16:56.544Z","comments":true,"path":"2020/11/13/react学习笔记/","link":"","permalink":"http://example.com/2020/11/13/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"React构建用户界面的JavaScript库,主要用于构建UI界面。Instagram，2013年开源。 特点： 声明式的设计 高校，采用虚拟DOM来实现dom的渲染，最大限度的减少dom的操作 灵活，跟其他库灵活搭配使用 jsx,俗称js里面写HTML,JAVASCRIPT 语法的扩展。 组件化，模块化。代码容易复用。 单项的数据流。没有实现数据的双向绑定。数据-》视图-》事件-》数据。 创建项目 1 、通过script引用使用，仅用于学习调式使用 12&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react@16&#x2F;umd&#x2F;react.development.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script crossorigin src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;react-dom@16&#x2F;umd&#x2F;react-dom.development.js&quot;&gt;&lt;&#x2F;script&gt; 2、通过react的脚手架，创建项目进行开发、部署。 安装脚手架 Create React App。cnpm install -g create-react-app。（使用cnpm安装需要先安装淘宝镜像 npm install -g cnpm –registry=https://registry.npm.taobao.org ） 创建项目 Create-React-App 01reactapp（项目名称可以自定义）。 React元素渲染 123let h1 &#x3D; &lt;h1&gt;helloword&lt;&#x2F;h1&gt;使用JSX的写法，可以创建js元素对象注意：JSX元素对象，或者组件对象，必须只有一个根元素（根节点） 案例使用： 123456789101112&#x2F;&#x2F; 实现页面时刻显示function clock() &#123; let time &#x3D; new Date().toLocaleTimeString() let element &#x3D; (&lt;div&gt; &lt;h1&gt;现在的时间&#123;time&#125;&lt;&#x2F;h1&gt; &lt;h2&gt;这是副标题&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt;) let root &#x3D; document.getElementById(&#39;root&#39;) ReactDOM.render(element, root);&#125;clock()setInterval(clock, 1000) 12345678910111213&#x2F;&#x2F; 函数式组件渲染function Clock(props)&#123; return(&lt;div&gt; &lt;h1&gt;现在的时间&#123;props.data.toLocaleTimeString()&#125;&lt;&#x2F;h1&gt; &lt;h2&gt;这是副标题&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt;)&#125;function run()&#123; ReactDOM.render(&lt;Clock data&#x3D;&#123;new Date()&#125;&#x2F;&gt;, document.querySelector(&quot;#root&quot;));&#125;setInterval(run,1000) React Jsx 优点： jsx执行更快，编译为JavaScript代码时进行优化。 类型更安全，编译过程出错就不能编译，能够及时发现错误 jsx编写模板更加简单快速（不要跟vue比） 注意： jsx必须要有根节点 正常的普通HTML元素要小写，如果是大写，则默认为组件。 Jsx表达式 由HTML元素构成 中间如果需要插入变量用{} {}中间可以使用表达式 {}中间表达式中可以使用JSX对象 属性和html内容一样都是用{}来插入内容","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"在项目上使用git","slug":"在项目上使用git","date":"2020-11-12T05:50:03.000Z","updated":"2020-12-16T09:57:03.504Z","comments":true,"path":"2020/11/12/在项目上使用git/","link":"","permalink":"http://example.com/2020/11/12/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BD%BF%E7%94%A8git/","excerpt":"","text":"git如何拉取最新项目和推送 在你需要加入一个项目开发时，需要在仓库把项目下载下来，进入gitlab， 在项目中找到你需要下载的项目地址，复制地址。这个地址分为http和ssh。 在本地创建了一个文件夹，进入文件里面，使用cmd（黑窗口）或者gitbash进行克隆项目。使用命令git clone 复制的http或ssh地址。 下载的下来的项目，进入到项目的下一目录，进入编剧器进行代码编剧时，我们首先需要拉取项目上最新的代码，git pull origin 分支名（分支名是你是从那个分支拉去下来的项目）。 在确定你的项目代码已经是最新的项目代码，在创建分支时，我们分为两种情况，一种是你跟你的同事不在一个分支上面进行项目编辑修改等，另一种情况在一个分支上面。你就进行创建你自己的分支：git branch 分支名，然后切换至你创建的分支：git checkout 分支名，当然你也可以一步直接创建并切换分支：git checkout -b 分支名 或者 git switch -c 分支名,。(如果您跟你的同事不在一个分支上面，分支名你可以按照自己的喜欢来命名（一般使用英文），但是你们在一个分支上面进行分组的话，命名就要根据大家的统一要求来) 查看创建的分支：git branch 当你对代码进行修改之后，需要添加到暂存区：git add . 或者 git add -A，两者均可o 提交暂存区的文件：git commit -m &quot;xx&quot;,双引号里面的xx代表的是对修改的内容做一个相关的解释，在每次修改代码时，如果不用git add提交到暂存区，是无法用commit进行提交。 从本地推送到分支上面，git push origin 分支名 切换至主分支，git checkout master 和 git switch master (一般默认主分支都为master) 删除本地分支：git branch -d 删除分支名：git branch -D 分支名,因为这个时候的分支还没有合并到当前分支，所以-D才能删除。 常用的git 命令 git status命令可以随时掌握工作区的状态 git diff命令可以查看被修改的部分。 在修改的时候我们可能会因为某些原因，觉得上一个版本才是合适的，所以这个时候需要怎么退回到上一个版本。HEAD指向的版本就是当前的版本，HEAD^指上一个版本，HEAD^^指上上一个版本，但是如果版本太多如第100个版本，则就用HEAD~100。 git可以使我们在任何一个版本，使用命令git reset --hard commit-d(commit-d提交的版本号id),使用git log就可以查看提交历史（，按住键盘q就能退出查看状态。），以便确定要退回到那个版本。 使用git reflog可以查看命令历史，以便确定要到回来的那个版本。 git撤销修改 当乱修改了工作区的某个文件内容，想直接丢弃工作内容的修改时，用命令 git checkout --file(文件名) 当你修改了工作区的某个文件，且还把他添加到暂存区时，想要丢弃修改，分成两步：第一步用命令 git reset HEAD (file)文件名，然后重复1 删除文件不同状况先手动删除文件，可以使用git rm (file) 和 git add (file)效果是一样的 如果不小心删错了文件，可以利用命令git checkout --(文件名)恢复到最新版本。","categories":[],"tags":[{"name":"git学习使用","slug":"git学习使用","permalink":"http://example.com/tags/git%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/"}]},{"title":"路径的使用","slug":"路径的使用","date":"2020-11-10T06:40:49.000Z","updated":"2020-11-12T05:41:37.894Z","comments":true,"path":"2020/11/10/路径的使用/","link":"","permalink":"http://example.com/2020/11/10/%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"在前端或者其他代码的使用，路径是一个不可缺少的部分。例如实际工作中，通常新建一个文件夹专门用于存放图像文件，这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。根目录 、当前目录。 路径可以分为：相对路径和绝对路径 1、相对路径 以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如img src=”logo.gif” 或者img src=”./logo.gif” 。 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如img src=”img/img01/logo.gif” 。 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如img src=”../logo.gif” 。 2、绝对路径 绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如“https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=4152598231,1037344495&amp;fm=173&amp;app=25&amp;f=JPEG?w=218&amp;h=146&amp;s=5807D810BD00EACE342B64C6030070BD”。","categories":[],"tags":[{"name":"路径","slug":"路径","permalink":"http://example.com/tags/%E8%B7%AF%E5%BE%84/"}]},{"title":"jQuery笔记","slug":"jQuery笔记","date":"2020-01-26T01:24:25.000Z","updated":"2020-12-17T01:44:29.417Z","comments":true,"path":"2020/01/26/jQuery笔记/","link":"","permalink":"http://example.com/2020/01/26/jQuery%E7%AC%94%E8%AE%B0/","excerpt":"","text":"jQuery是一个快速、简洁的JavaScript框架，是继承Prototype之后的又一个优秀的JavaScript代码库，jQuery的设计宗旨是“write less，do more”,提倡写更少的代码，做更多的事情，它封装JavaScript常用的功能代码，提供的是一种JavaScript的简便模式，优化HTMl文档操作、事件处理、动画设计和Ajax交互。 jQuery特点 代码小巧 操作比较方便 兼容主流浏览器 优雅的语法规则 支持扩展功能 封装繁琐的底层技术 框架封闭 自成体系 丰富完善的的学习和应用环境 安装jQuery 进入jQuery网站 在打开的页面上选择你需要下载的版本。 复制已下载的jQuery脚本到站点中，如站点根目录下的jQuery的文件内。 启动vscode,新建文档，保存为test.html jQuery框架不需要安装，在网页文档的头部导入jQuery框架的源代码文件即可。导入的文件可以使用相对路劲，也可以使用绝对路劲，具体根据读者存放jQuery库文件的位置而定。 ​","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"浏览器引擎","slug":"浏览器引擎","date":"2019-11-10T03:25:33.000Z","updated":"2020-11-17T08:52:35.845Z","comments":true,"path":"2019/11/10/浏览器引擎/","link":"","permalink":"http://example.com/2019/11/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E/","excerpt":"","text":"浏览器解析渲染页面原理 浏览器 最重要 最核心的部分是“解释引擎”，也就是“浏览器内核”： 负责对网页语法的解释（如HTML、JavaScript）并渲染（显示）网页。网页的工作过程需要使用到两个引擎：渲染引擎和javascript引擎什么是JavaScript引擎？简单来讲，就是能够提供执行JavaScript代码的运行环境所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，排版引擎(Rendering Engine，也有称渲染引擎)，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。浏览器内核很多，如果加上所有的几乎没有什么人在用的非商业的免费内核，那么可能大约有10款以上甚至更多，不过通常我们比较常见的大约只有以下四种： Trident ：[ˈtraɪdnt]IE浏览器(遨游、世界之窗、腾讯TT…都是IE)Trident内核最慢IE 以Trident 作为内核引擎 ,前缀为–ms。 Gecko：[ˈgekəʊ] 开放源代码、以C++编写的网页排版引擎，是跨平台的FireFox是基于 Gecko 开发; presto：[ˈprestəʊ]目前公认网页浏览速度最快的浏览器内核，然而代价是牺牲了网页的兼容性。由Opera Software开发的浏览器排版引擎，Opera（欧朋浏览器），但由于市场选择问题，主要应用在手机平台–Opera mini Webkit：苹果公司自己的内核，google的chrome也使用webkit作为内核。是一个开源的浏览器引擎，同时WebKit 也是苹果Mac OS X 系统引擎框架版本的名称，它拥有清晰的源码结构、极快的渲染速度，包含的 WebCore 排版引擎和 JavaScriptCore解析引擎，均是从KDE的KHTML及KJS引擎衍生而来。许多网站都是按照IE来架设的，很多网站不兼容Webkit内核，比如登录界面、网银等网页均不可使用Webkit内核的浏览器。Safari([səˈfɑri]), Google Chrome, 傲游3, 猎豹浏览器, 百度浏览器 opera浏览器 基于 Webkit 开发。 注：2013年2月Opera宣布转向WebKit引擎注：2013年4月Opera宣布放弃WEBKIT，跟随GOOGLE的新开发的blink引擎","categories":[],"tags":[{"name":"浏览器解析渲染页面原理","slug":"浏览器解析渲染页面原理","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E5%8E%9F%E7%90%86/"}]},{"title":"行类元素、块级元素","slug":"行类元素、块级元素","date":"2019-07-17T08:51:16.000Z","updated":"2020-12-16T10:00:05.776Z","comments":true,"path":"2019/07/17/行类元素、块级元素/","link":"","permalink":"http://example.com/2019/07/17/%E8%A1%8C%E7%B1%BB%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/","excerpt":"","text":"行类元素与块级元素的区别行类元素：不会独自占用一行，会和其他行类元素排在一行；不能设置宽高，默认的宽高是内容撑起来的。常见的行类元素有a、b、u、span、i、em、strong等文字标签。 块级元素：独自占用一行，有自己的宽度和高度。常见的有div、table、tr、form、ul、li、ol、 h1~h6、p。行内块元素：有自己的宽高，不会独自占用一行。常见的img、input、select等。 常见的空元素：img、hr、br、input、meta等。 通过设置display的属性可以使行类元素和块级元素相互转换，行类元素转换为块级元素，display：block,块级元素转化为行类元素：display：inline。 BFC规范理解BFC（Block Formatting Context）块级格式化上下文，是web页面中盒模型布局的css渲染模式，指一个独立的渲染区或者说是一个隔离的独立容器。形成条件： 根元素HTML标签； 浮动元素，float值为left,right; display的值为inline-block，table-cell,table-caption; overflow的值为hidden，auto,scroll; position的值为absolute，fixed; BFC形成特征： 内部的box会在垂直方向上一个接一个的位置； 垂直方向上的距离由margin决定； BFC区域不会与float区域重叠； 计算BFC的高度时，浮动元素也参与计算； BfC就是一个独立容器，容器里面的子元素不会影响外面的元素 提高CSS优化、性能的方法 多个css合并，尽量减少http请求； 将css文件放在页面的最上面； 移除空的css规则； 避免使用css表达式； 选择优化嵌套，尽量避免层级； 充分利用CSS继承属性，减少代码量； 属性值为0时，不加单位； 属性值小于1时，前面的0可以省略不写； css sprite(使用精灵图) 浏览器得渲染过程，DOM树和渲染树得区别浏览器得渲染过程： 解析HTML构建DOM(dom树)，并行请求css/image/js； css文件下载完成，开始构建cssom(css树)； css树构建结束后，和DOM一起生成Render Tree(渲染树)； 布局（layout）:计算出每个节点在屏幕中得位置； 显示（painting）:通过显卡把页面画到屏幕上。 DOM树和渲染树的区别： DOM树与HTML标签一一对应，包括head和隐藏元素； 渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性。 什么是闭包 定义和用法：当一个数的返回值是另一个函数，而返回的函数调用了其父函数内部的变量，那么返回的函数在被外部执行时，就产生了闭包。 表现形式：使函数外部能够调用函数内部定义的变量。 实例如下：根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined。这里明显count 是函数内部的flag2 的那个count。 ​ 123456789101112var count&#x3D;10; &#x2F;&#x2F;全局作用域 标记为flag1function add () &#123; var count&#x3D;0; &#x2F;&#x2F;函数全局作用域 标记为flag2 return function () &#123; count+&#x3D;1; &#x2F;&#x2F; count&#x3D;count+1函数的内部作用域 alert(count); &#125;&#125;var s &#x3D; add ();s();&#x2F;&#x2F;输出1s();&#x2F;&#x2F;输出2 4.变量的作用域： 要理解闭包，首先必须理解JS特殊的变量作用域。变量的作用域分类：全局变量和局部变量。 5.特点： 函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内部局部变量。 函数内部声明变量的时候，一定要使用var命令。如果不用的话，实际就是声明了一个全局变量。 使用闭包的注意点： 滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的的公用方法（public method）,把内部变量当作它的私有属性（private value）,这时一定要小心，不要随便改变函数内部变量的值。 在es5与es6中遇到空元素在不同状况下的打印情况 解析: 在es5中，遇到forEach(), filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，但是不会对空数组进行检测, reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。但是对于空数组是不会执行回调函数的。 every()方法用于检测数组所有元素是否都符合指定条件，如果检测到一个元素不满足，则整个表达式都返回false,且剩余的元素也不会在进行检查。不会对空数组进行检查。 some()用于检测数组中的元素是否满足检查条件，会依次检查数组中的每个元素，如果有一个元素满足条件，则整个表达式返回true,剩余的元素就不在执行检测。不会对空数组进行检测。 map()会跳过空位，但是会保留跳过的空值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 es6中都会将空位变为undefined new操作符具体干了什么创建实例对象，this变量引用该对象，同时还继承了构造函数的原型； 属性和方法被加入到this引用的对象中； 新创建的对象由this所引用，并且最后隐式的返回this； 箭头函数与普通函数的区别箭头函数是普通函数的简写，可以更加优雅的定义一个函数，和普通函数相比，有以下几点差异： 函数体内的this是定义时所在的对象，而不是使用时所在的对象。 不可以使用arguments对象，可以使用rest参数代替。 不可使用yield命令，因此箭头函数不能用作Generator函数。 不能使用new命令，因为： ​ 没有自己的this,无法调用call,apply。 ​ 没有prototype属性，而new命令在执行时需要构造函数的prototype赋值给新的对象的_ proto _。","categories":[],"tags":[{"name":"行类元素与块级元素的区别","slug":"行类元素与块级元素的区别","permalink":"http://example.com/tags/%E8%A1%8C%E7%B1%BB%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB/"}]}],"categories":[],"tags":[{"name":"前端笔试","slug":"前端笔试","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95/"},{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"git学习使用","slug":"git学习使用","permalink":"http://example.com/tags/git%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/"},{"name":"路径","slug":"路径","permalink":"http://example.com/tags/%E8%B7%AF%E5%BE%84/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"浏览器解析渲染页面原理","slug":"浏览器解析渲染页面原理","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E5%8E%9F%E7%90%86/"},{"name":"行类元素与块级元素的区别","slug":"行类元素与块级元素的区别","permalink":"http://example.com/tags/%E8%A1%8C%E7%B1%BB%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB/"}]}